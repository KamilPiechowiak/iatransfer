<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>iatransfer.toolkit.standardization.graph_standardization API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>iatransfer.toolkit.standardization.graph_standardization</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import random
from collections import Counter
from typing import List, Tuple, Union, Dict

import torch
import torch.nn as nn
from graphviz import Digraph
from torch.autograd import Variable

from iatransfer.toolkit.base_standardization import Standardization


class GraphStandardization(Standardization):
    &#34;&#34;&#34;Graph standardization algorithm for IAT.
    &#34;&#34;&#34;

    def standardize(self, module: nn.Module, *args, **kwargs) \
            -&gt; List[Union[nn.Module, List[nn.Module]]]:
        return self.get_blocks(module)

    def make_dot(self, var, params=None):

        def resize_graph(dot, size_per_element=0.15, min_size=12):
            num_rows = len(dot.body)
            content_size = num_rows * size_per_element
            size = max(min_size, content_size)
            size_str = str(size) + &#34;,&#34; + str(size)
            dot.graph_attr.update(size=size_str)
            return size

        if params is not None:
            assert all(isinstance(p, Variable) for p in params.values())
            param_map = {id(v): k for k, v in params.items()}

        node_attr = dict(
            style=&#34;filled&#34;,
            shape=&#34;box&#34;,
            align=&#34;left&#34;,
            fontsize=&#34;12&#34;,
            ranksep=&#34;0.1&#34;,
            height=&#34;0.2&#34;,
        )

        idx = random.randint(1, 100000)
        dot = Digraph(
            name=f&#34;cluster_{idx}&#34;, node_attr=node_attr, graph_attr=dict(size=&#34;12,12&#34;)
        )
        seen = set()

        def size_to_str(size):
            return &#34;(&#34; + (&#34;, &#34;).join([&#34;%d&#34; % v for v in size]) + &#34;)&#34;

        mod_op = [&#34;AddBackward0&#34;, &#34;MulBackward0&#34;, &#34;CatBackward&#34;]

        lmap, emap, hmap = {}, {}, {}
        elist, clist = [], []

        def add_nodes(var, root=None, c=0, depth=0, branch=0, global_i=0):
            if var in seen:
                return None

            depth += 1
            global_i += 1

            if c not in lmap:
                lmap[c], emap[c] = [], []

            # FIXME: move to function
            if hasattr(var, &#34;variable&#34;):
                u = var.variable
                name = param_map[id(u)] if params is not None else &#34;&#34;
                node_name = &#34;%s\n %s&#34; % (name, size_to_str(u.size()))
                lmap[c].append(
                    {
                        &#34;branch&#34;: branch,
                        &#34;depth&#34;: depth,
                        &#34;global_i&#34;: global_i,
                        &#34;name&#34;: name,
                        &#34;size&#34;: u.size(),
                        &#34;type&#34;: &#34;param&#34;,
                        &#34;id&#34;: str(id(var)),
                    }
                )
                hmap[name] = str(id(var))
                dot.node(
                    str(id(var)),
                    f&#34;c={c} branch={branch} depth={depth}\n&#34; + node_name,
                    fillcolor=&#34;lightblue&#34;,
                )
            else:
                node_name = str(type(var).__name__)
                if node_name in mod_op:
                    depth = 0
                    prev_c = c
                    c = str(id(var))
                    clist.append((c, prev_c))
                    emap[c], lmap[c] = [], []
                    dot.node(str(id(var)), node_name + f&#34; [{c}]&#34;, fillcolor=&#34;green&#34;)
                else:
                    lmap[c].append(
                        {
                            &#34;branch&#34;: branch,
                            &#34;depth&#34;: depth,
                            &#34;global_i&#34;: global_i,
                            &#34;name&#34;: node_name,
                            &#34;type&#34;: &#34;func&#34;,
                            &#34;id&#34;: str(id(var)),
                        }
                    )
                    dot.node(str(id(var)), node_name + f&#34; [{str(id(var))}]&#34;)
            if root:
                emap[c].append((str(id(var)), root))
            seen.add(var)

            if hasattr(var, &#34;next_functions&#34;):
                for _branch, u in enumerate(var.next_functions):
                    if node_name in mod_op:
                        branch = _branch
                    if u[0] is not None:
                        dot.edge(str(id(u[0])), str(id(var)), color=&#34;blue&#34;)
                        elist.append((str(id(u[0])), str(id(var))))
                        add_nodes(
                            u[0],
                            root=str(id(var)),
                            c=c,
                            depth=depth,
                            branch=branch,
                            global_i=global_i,
                        )

        if isinstance(var, tuple):
            for v in var:
                add_nodes(v.grad_fn)
        else:
            add_nodes(var.grad_fn)

        for c, edges in emap.items():
            with dot.subgraph(name=f&#34;cluster_{idx}_{c}&#34;) as _c:
                _c.attr(color=&#34;blue&#34;)
                _c.attr(style=&#34;filled&#34;, color=&#34;lightgrey&#34;)
                _c.node_attr[&#34;style&#34;] = &#34;filled&#34;
                _c.edges(edges)
                _c.attr(label=f&#34;cluster {c}&#34;)

        return dot, lmap, hmap, clist, elist

    def get_graph(self, model: nn.Module):
        # FIXME: warning about &#39;torchviz&#39;
        try:
            x = torch.randn(32, 3, 32, 32)
            g, lmap, hmap, clist, elist = self.make_dot(model(x), params=dict(model.named_parameters()))
        except:
            # FIXME: universal head? (what happens if MNIST?)
            print(&#34;ERROR: trying one channel&#34;)
            x = torch.randn(32, 1, 31, 31)
            g, lmap, hmap, clist, elist = self.make_dot(model(x), params=dict(model.named_parameters()))
        return g, lmap, hmap, clist, elist

    def get_layers(self, model: nn.Module) -&gt; Dict[str, nn.Module]:
        layers_dict = {}

        def dfs(model: nn.Module, name_prefix: List[str]):
            for child_name, child in model.named_children():
                dfs(child, name_prefix + [child_name])
            layers_dict[&#34;.&#34;.join(name_prefix)] = model

        dfs(model, [])
        return layers_dict

    def sort_graph(self, graph: &#39;Graph&#39;, clusters_edges: List[Tuple[str, str]],
                   nodes_edges: List[Tuple[str, str]]) -&gt; &#39;Graph&#39;:

        def topological_sort(edges: List[Tuple[str, str]]) -&gt; Dict[str, int]:
            def dfs(a: &#39;Node&#39;):
                nonlocal postorder
                a[&#39;vis&#39;] = True
                for bid in a[&#39;e&#39;]:
                    b = nodes[bid]
                    if not b[&#39;vis&#39;]:
                        dfs(b)
                a[&#39;postorder&#39;] = postorder
                postorder += 1

            nodes = set([e[0] for e in edges]) | set([e[1] for e in edges])
            nodes = dict([
                (node, {&#39;id&#39;: node, &#39;e&#39;: [], &#39;postorder&#39;: -1, &#39;vis&#39;: False}) for node in nodes
            ])
            for e in edges:
                nodes[e[0]][&#39;e&#39;].append(e[1])
            postorder = 0
            for node in nodes.values():
                if node[&#39;postorder&#39;] == -1:
                    dfs(node)
            ordered_nodes = sorted(list(nodes.values()), key=lambda node: -node[&#39;postorder&#39;])
            return dict([(node[&#39;id&#39;], i) for i, node in enumerate(ordered_nodes)])

        def count_ancestors(edges: List[Tuple[str, str]]) -&gt; Dict[str, int]:
            return

        def sort_cluster(cluster: List[&#39;Node&#39;]) -&gt; List[&#39;Node&#39;]:
            def cmp(node: &#39;Node&#39;) -&gt; int:
                if node[&#39;type&#39;] == &#39;param&#39;:
                    a = node_child[node[&#39;id&#39;]]
                    while parents_count[a] == 1:
                        a = node_child[a]
                    return nodes_order[a]
                else:
                    return nodes_order[node[&#34;id&#34;]]

            return sorted(cluster, key=cmp)

        clusters_order = topological_sort(clusters_edges)
        node_child = dict(nodes_edges)
        nodes_order = topological_sort(nodes_edges)
        parents_count = Counter([e[1] for e in nodes_edges])

        new_graph = {}
        for cid in clusters_order.keys():
            cluster = graph[cid]
            cluster = sort_cluster(cluster)
            new_graph[cid] = cluster
        return new_graph

    def get_blocks(self, model: nn.Module) -&gt; List[Union[nn.Module, List[nn.Module]]]:
        _, graph, _, clusters_edges, nodes_edges = self.get_graph(model)
        graph = self.sort_graph(graph, clusters_edges, nodes_edges)
        layers_dict = self.get_layers(model)
        layers = []
        for block in graph.values():
            layers_in_block = []
            for layer in block:
                if layer[&#39;name&#39;].endswith(&#39;.weight&#39;):
                    name = layer[&#39;name&#39;].replace(&#39;.weight&#39;, &#39;&#39;)
                    layers_in_block.append(layers_dict[name])
            layers.append(layers_in_block)
        return layers</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization"><code class="flex name class">
<span>class <span class="ident">GraphStandardization</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph standardization algorithm for IAT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphStandardization(Standardization):
    &#34;&#34;&#34;Graph standardization algorithm for IAT.
    &#34;&#34;&#34;

    def standardize(self, module: nn.Module, *args, **kwargs) \
            -&gt; List[Union[nn.Module, List[nn.Module]]]:
        return self.get_blocks(module)

    def make_dot(self, var, params=None):

        def resize_graph(dot, size_per_element=0.15, min_size=12):
            num_rows = len(dot.body)
            content_size = num_rows * size_per_element
            size = max(min_size, content_size)
            size_str = str(size) + &#34;,&#34; + str(size)
            dot.graph_attr.update(size=size_str)
            return size

        if params is not None:
            assert all(isinstance(p, Variable) for p in params.values())
            param_map = {id(v): k for k, v in params.items()}

        node_attr = dict(
            style=&#34;filled&#34;,
            shape=&#34;box&#34;,
            align=&#34;left&#34;,
            fontsize=&#34;12&#34;,
            ranksep=&#34;0.1&#34;,
            height=&#34;0.2&#34;,
        )

        idx = random.randint(1, 100000)
        dot = Digraph(
            name=f&#34;cluster_{idx}&#34;, node_attr=node_attr, graph_attr=dict(size=&#34;12,12&#34;)
        )
        seen = set()

        def size_to_str(size):
            return &#34;(&#34; + (&#34;, &#34;).join([&#34;%d&#34; % v for v in size]) + &#34;)&#34;

        mod_op = [&#34;AddBackward0&#34;, &#34;MulBackward0&#34;, &#34;CatBackward&#34;]

        lmap, emap, hmap = {}, {}, {}
        elist, clist = [], []

        def add_nodes(var, root=None, c=0, depth=0, branch=0, global_i=0):
            if var in seen:
                return None

            depth += 1
            global_i += 1

            if c not in lmap:
                lmap[c], emap[c] = [], []

            # FIXME: move to function
            if hasattr(var, &#34;variable&#34;):
                u = var.variable
                name = param_map[id(u)] if params is not None else &#34;&#34;
                node_name = &#34;%s\n %s&#34; % (name, size_to_str(u.size()))
                lmap[c].append(
                    {
                        &#34;branch&#34;: branch,
                        &#34;depth&#34;: depth,
                        &#34;global_i&#34;: global_i,
                        &#34;name&#34;: name,
                        &#34;size&#34;: u.size(),
                        &#34;type&#34;: &#34;param&#34;,
                        &#34;id&#34;: str(id(var)),
                    }
                )
                hmap[name] = str(id(var))
                dot.node(
                    str(id(var)),
                    f&#34;c={c} branch={branch} depth={depth}\n&#34; + node_name,
                    fillcolor=&#34;lightblue&#34;,
                )
            else:
                node_name = str(type(var).__name__)
                if node_name in mod_op:
                    depth = 0
                    prev_c = c
                    c = str(id(var))
                    clist.append((c, prev_c))
                    emap[c], lmap[c] = [], []
                    dot.node(str(id(var)), node_name + f&#34; [{c}]&#34;, fillcolor=&#34;green&#34;)
                else:
                    lmap[c].append(
                        {
                            &#34;branch&#34;: branch,
                            &#34;depth&#34;: depth,
                            &#34;global_i&#34;: global_i,
                            &#34;name&#34;: node_name,
                            &#34;type&#34;: &#34;func&#34;,
                            &#34;id&#34;: str(id(var)),
                        }
                    )
                    dot.node(str(id(var)), node_name + f&#34; [{str(id(var))}]&#34;)
            if root:
                emap[c].append((str(id(var)), root))
            seen.add(var)

            if hasattr(var, &#34;next_functions&#34;):
                for _branch, u in enumerate(var.next_functions):
                    if node_name in mod_op:
                        branch = _branch
                    if u[0] is not None:
                        dot.edge(str(id(u[0])), str(id(var)), color=&#34;blue&#34;)
                        elist.append((str(id(u[0])), str(id(var))))
                        add_nodes(
                            u[0],
                            root=str(id(var)),
                            c=c,
                            depth=depth,
                            branch=branch,
                            global_i=global_i,
                        )

        if isinstance(var, tuple):
            for v in var:
                add_nodes(v.grad_fn)
        else:
            add_nodes(var.grad_fn)

        for c, edges in emap.items():
            with dot.subgraph(name=f&#34;cluster_{idx}_{c}&#34;) as _c:
                _c.attr(color=&#34;blue&#34;)
                _c.attr(style=&#34;filled&#34;, color=&#34;lightgrey&#34;)
                _c.node_attr[&#34;style&#34;] = &#34;filled&#34;
                _c.edges(edges)
                _c.attr(label=f&#34;cluster {c}&#34;)

        return dot, lmap, hmap, clist, elist

    def get_graph(self, model: nn.Module):
        # FIXME: warning about &#39;torchviz&#39;
        try:
            x = torch.randn(32, 3, 32, 32)
            g, lmap, hmap, clist, elist = self.make_dot(model(x), params=dict(model.named_parameters()))
        except:
            # FIXME: universal head? (what happens if MNIST?)
            print(&#34;ERROR: trying one channel&#34;)
            x = torch.randn(32, 1, 31, 31)
            g, lmap, hmap, clist, elist = self.make_dot(model(x), params=dict(model.named_parameters()))
        return g, lmap, hmap, clist, elist

    def get_layers(self, model: nn.Module) -&gt; Dict[str, nn.Module]:
        layers_dict = {}

        def dfs(model: nn.Module, name_prefix: List[str]):
            for child_name, child in model.named_children():
                dfs(child, name_prefix + [child_name])
            layers_dict[&#34;.&#34;.join(name_prefix)] = model

        dfs(model, [])
        return layers_dict

    def sort_graph(self, graph: &#39;Graph&#39;, clusters_edges: List[Tuple[str, str]],
                   nodes_edges: List[Tuple[str, str]]) -&gt; &#39;Graph&#39;:

        def topological_sort(edges: List[Tuple[str, str]]) -&gt; Dict[str, int]:
            def dfs(a: &#39;Node&#39;):
                nonlocal postorder
                a[&#39;vis&#39;] = True
                for bid in a[&#39;e&#39;]:
                    b = nodes[bid]
                    if not b[&#39;vis&#39;]:
                        dfs(b)
                a[&#39;postorder&#39;] = postorder
                postorder += 1

            nodes = set([e[0] for e in edges]) | set([e[1] for e in edges])
            nodes = dict([
                (node, {&#39;id&#39;: node, &#39;e&#39;: [], &#39;postorder&#39;: -1, &#39;vis&#39;: False}) for node in nodes
            ])
            for e in edges:
                nodes[e[0]][&#39;e&#39;].append(e[1])
            postorder = 0
            for node in nodes.values():
                if node[&#39;postorder&#39;] == -1:
                    dfs(node)
            ordered_nodes = sorted(list(nodes.values()), key=lambda node: -node[&#39;postorder&#39;])
            return dict([(node[&#39;id&#39;], i) for i, node in enumerate(ordered_nodes)])

        def count_ancestors(edges: List[Tuple[str, str]]) -&gt; Dict[str, int]:
            return

        def sort_cluster(cluster: List[&#39;Node&#39;]) -&gt; List[&#39;Node&#39;]:
            def cmp(node: &#39;Node&#39;) -&gt; int:
                if node[&#39;type&#39;] == &#39;param&#39;:
                    a = node_child[node[&#39;id&#39;]]
                    while parents_count[a] == 1:
                        a = node_child[a]
                    return nodes_order[a]
                else:
                    return nodes_order[node[&#34;id&#34;]]

            return sorted(cluster, key=cmp)

        clusters_order = topological_sort(clusters_edges)
        node_child = dict(nodes_edges)
        nodes_order = topological_sort(nodes_edges)
        parents_count = Counter([e[1] for e in nodes_edges])

        new_graph = {}
        for cid in clusters_order.keys():
            cluster = graph[cid]
            cluster = sort_cluster(cluster)
            new_graph[cid] = cluster
        return new_graph

    def get_blocks(self, model: nn.Module) -&gt; List[Union[nn.Module, List[nn.Module]]]:
        _, graph, _, clusters_edges, nodes_edges = self.get_graph(model)
        graph = self.sort_graph(graph, clusters_edges, nodes_edges)
        layers_dict = self.get_layers(model)
        layers = []
        for block in graph.values():
            layers_in_block = []
            for layer in block:
                if layer[&#39;name&#39;].endswith(&#39;.weight&#39;):
                    name = layer[&#39;name&#39;].replace(&#39;.weight&#39;, &#39;&#39;)
                    layers_in_block.append(layers_dict[name])
            layers.append(layers_in_block)
        return layers</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="iatransfer.toolkit.base_standardization.Standardization" href="../base_standardization.html#iatransfer.toolkit.base_standardization.Standardization">Standardization</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_blocks"><code class="name flex">
<span>def <span class="ident">get_blocks</span></span>(<span>self, model: nn.Module) ‑> List[Union[torch.nn.modules.module.Module, List[torch.nn.modules.module.Module]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blocks(self, model: nn.Module) -&gt; List[Union[nn.Module, List[nn.Module]]]:
    _, graph, _, clusters_edges, nodes_edges = self.get_graph(model)
    graph = self.sort_graph(graph, clusters_edges, nodes_edges)
    layers_dict = self.get_layers(model)
    layers = []
    for block in graph.values():
        layers_in_block = []
        for layer in block:
            if layer[&#39;name&#39;].endswith(&#39;.weight&#39;):
                name = layer[&#39;name&#39;].replace(&#39;.weight&#39;, &#39;&#39;)
                layers_in_block.append(layers_dict[name])
        layers.append(layers_in_block)
    return layers</code></pre>
</details>
</dd>
<dt id="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_graph"><code class="name flex">
<span>def <span class="ident">get_graph</span></span>(<span>self, model: nn.Module)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_graph(self, model: nn.Module):
    # FIXME: warning about &#39;torchviz&#39;
    try:
        x = torch.randn(32, 3, 32, 32)
        g, lmap, hmap, clist, elist = self.make_dot(model(x), params=dict(model.named_parameters()))
    except:
        # FIXME: universal head? (what happens if MNIST?)
        print(&#34;ERROR: trying one channel&#34;)
        x = torch.randn(32, 1, 31, 31)
        g, lmap, hmap, clist, elist = self.make_dot(model(x), params=dict(model.named_parameters()))
    return g, lmap, hmap, clist, elist</code></pre>
</details>
</dd>
<dt id="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_layers"><code class="name flex">
<span>def <span class="ident">get_layers</span></span>(<span>self, model: nn.Module) ‑> Dict[str, torch.nn.modules.module.Module]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_layers(self, model: nn.Module) -&gt; Dict[str, nn.Module]:
    layers_dict = {}

    def dfs(model: nn.Module, name_prefix: List[str]):
        for child_name, child in model.named_children():
            dfs(child, name_prefix + [child_name])
        layers_dict[&#34;.&#34;.join(name_prefix)] = model

    dfs(model, [])
    return layers_dict</code></pre>
</details>
</dd>
<dt id="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.make_dot"><code class="name flex">
<span>def <span class="ident">make_dot</span></span>(<span>self, var, params=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_dot(self, var, params=None):

    def resize_graph(dot, size_per_element=0.15, min_size=12):
        num_rows = len(dot.body)
        content_size = num_rows * size_per_element
        size = max(min_size, content_size)
        size_str = str(size) + &#34;,&#34; + str(size)
        dot.graph_attr.update(size=size_str)
        return size

    if params is not None:
        assert all(isinstance(p, Variable) for p in params.values())
        param_map = {id(v): k for k, v in params.items()}

    node_attr = dict(
        style=&#34;filled&#34;,
        shape=&#34;box&#34;,
        align=&#34;left&#34;,
        fontsize=&#34;12&#34;,
        ranksep=&#34;0.1&#34;,
        height=&#34;0.2&#34;,
    )

    idx = random.randint(1, 100000)
    dot = Digraph(
        name=f&#34;cluster_{idx}&#34;, node_attr=node_attr, graph_attr=dict(size=&#34;12,12&#34;)
    )
    seen = set()

    def size_to_str(size):
        return &#34;(&#34; + (&#34;, &#34;).join([&#34;%d&#34; % v for v in size]) + &#34;)&#34;

    mod_op = [&#34;AddBackward0&#34;, &#34;MulBackward0&#34;, &#34;CatBackward&#34;]

    lmap, emap, hmap = {}, {}, {}
    elist, clist = [], []

    def add_nodes(var, root=None, c=0, depth=0, branch=0, global_i=0):
        if var in seen:
            return None

        depth += 1
        global_i += 1

        if c not in lmap:
            lmap[c], emap[c] = [], []

        # FIXME: move to function
        if hasattr(var, &#34;variable&#34;):
            u = var.variable
            name = param_map[id(u)] if params is not None else &#34;&#34;
            node_name = &#34;%s\n %s&#34; % (name, size_to_str(u.size()))
            lmap[c].append(
                {
                    &#34;branch&#34;: branch,
                    &#34;depth&#34;: depth,
                    &#34;global_i&#34;: global_i,
                    &#34;name&#34;: name,
                    &#34;size&#34;: u.size(),
                    &#34;type&#34;: &#34;param&#34;,
                    &#34;id&#34;: str(id(var)),
                }
            )
            hmap[name] = str(id(var))
            dot.node(
                str(id(var)),
                f&#34;c={c} branch={branch} depth={depth}\n&#34; + node_name,
                fillcolor=&#34;lightblue&#34;,
            )
        else:
            node_name = str(type(var).__name__)
            if node_name in mod_op:
                depth = 0
                prev_c = c
                c = str(id(var))
                clist.append((c, prev_c))
                emap[c], lmap[c] = [], []
                dot.node(str(id(var)), node_name + f&#34; [{c}]&#34;, fillcolor=&#34;green&#34;)
            else:
                lmap[c].append(
                    {
                        &#34;branch&#34;: branch,
                        &#34;depth&#34;: depth,
                        &#34;global_i&#34;: global_i,
                        &#34;name&#34;: node_name,
                        &#34;type&#34;: &#34;func&#34;,
                        &#34;id&#34;: str(id(var)),
                    }
                )
                dot.node(str(id(var)), node_name + f&#34; [{str(id(var))}]&#34;)
        if root:
            emap[c].append((str(id(var)), root))
        seen.add(var)

        if hasattr(var, &#34;next_functions&#34;):
            for _branch, u in enumerate(var.next_functions):
                if node_name in mod_op:
                    branch = _branch
                if u[0] is not None:
                    dot.edge(str(id(u[0])), str(id(var)), color=&#34;blue&#34;)
                    elist.append((str(id(u[0])), str(id(var))))
                    add_nodes(
                        u[0],
                        root=str(id(var)),
                        c=c,
                        depth=depth,
                        branch=branch,
                        global_i=global_i,
                    )

    if isinstance(var, tuple):
        for v in var:
            add_nodes(v.grad_fn)
    else:
        add_nodes(var.grad_fn)

    for c, edges in emap.items():
        with dot.subgraph(name=f&#34;cluster_{idx}_{c}&#34;) as _c:
            _c.attr(color=&#34;blue&#34;)
            _c.attr(style=&#34;filled&#34;, color=&#34;lightgrey&#34;)
            _c.node_attr[&#34;style&#34;] = &#34;filled&#34;
            _c.edges(edges)
            _c.attr(label=f&#34;cluster {c}&#34;)

    return dot, lmap, hmap, clist, elist</code></pre>
</details>
</dd>
<dt id="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.sort_graph"><code class="name flex">
<span>def <span class="ident">sort_graph</span></span>(<span>self, graph: "'Graph'", clusters_edges: List[Tuple[str, str]], nodes_edges: List[Tuple[str, str]]) ‑> Graph</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_graph(self, graph: &#39;Graph&#39;, clusters_edges: List[Tuple[str, str]],
               nodes_edges: List[Tuple[str, str]]) -&gt; &#39;Graph&#39;:

    def topological_sort(edges: List[Tuple[str, str]]) -&gt; Dict[str, int]:
        def dfs(a: &#39;Node&#39;):
            nonlocal postorder
            a[&#39;vis&#39;] = True
            for bid in a[&#39;e&#39;]:
                b = nodes[bid]
                if not b[&#39;vis&#39;]:
                    dfs(b)
            a[&#39;postorder&#39;] = postorder
            postorder += 1

        nodes = set([e[0] for e in edges]) | set([e[1] for e in edges])
        nodes = dict([
            (node, {&#39;id&#39;: node, &#39;e&#39;: [], &#39;postorder&#39;: -1, &#39;vis&#39;: False}) for node in nodes
        ])
        for e in edges:
            nodes[e[0]][&#39;e&#39;].append(e[1])
        postorder = 0
        for node in nodes.values():
            if node[&#39;postorder&#39;] == -1:
                dfs(node)
        ordered_nodes = sorted(list(nodes.values()), key=lambda node: -node[&#39;postorder&#39;])
        return dict([(node[&#39;id&#39;], i) for i, node in enumerate(ordered_nodes)])

    def count_ancestors(edges: List[Tuple[str, str]]) -&gt; Dict[str, int]:
        return

    def sort_cluster(cluster: List[&#39;Node&#39;]) -&gt; List[&#39;Node&#39;]:
        def cmp(node: &#39;Node&#39;) -&gt; int:
            if node[&#39;type&#39;] == &#39;param&#39;:
                a = node_child[node[&#39;id&#39;]]
                while parents_count[a] == 1:
                    a = node_child[a]
                return nodes_order[a]
            else:
                return nodes_order[node[&#34;id&#34;]]

        return sorted(cluster, key=cmp)

    clusters_order = topological_sort(clusters_edges)
    node_child = dict(nodes_edges)
    nodes_order = topological_sort(nodes_edges)
    parents_count = Counter([e[1] for e in nodes_edges])

    new_graph = {}
    for cid in clusters_order.keys():
        cluster = graph[cid]
        cluster = sort_cluster(cluster)
        new_graph[cid] = cluster
    return new_graph</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="iatransfer.toolkit.base_standardization.Standardization" href="../base_standardization.html#iatransfer.toolkit.base_standardization.Standardization">Standardization</a></b></code>:
<ul class="hlist">
<li><code><a title="iatransfer.toolkit.base_standardization.Standardization.standardize" href="../base_standardization.html#iatransfer.toolkit.base_standardization.Standardization.standardize">standardize</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="iatransfer.toolkit.standardization" href="index.html">iatransfer.toolkit.standardization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization" href="#iatransfer.toolkit.standardization.graph_standardization.GraphStandardization">GraphStandardization</a></code></h4>
<ul class="">
<li><code><a title="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_blocks" href="#iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_blocks">get_blocks</a></code></li>
<li><code><a title="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_graph" href="#iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_graph">get_graph</a></code></li>
<li><code><a title="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_layers" href="#iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.get_layers">get_layers</a></code></li>
<li><code><a title="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.make_dot" href="#iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.make_dot">make_dot</a></code></li>
<li><code><a title="iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.sort_graph" href="#iatransfer.toolkit.standardization.graph_standardization.GraphStandardization.sort_graph">sort_graph</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>